{"version":3,"file":"react-easy-sort.min.js","sources":["../../src/helpers.ts","../../src/hooks.tsx","../../src/index.tsx"],"sourcesContent":["import { Point } from './types'\n\n/**\n * This function check if a given point is inside of the items rect.\n * If it's not inside any rect, it will return the index of the closest rect\n */\nexport const findItemIndexAtPosition = (\n  { x, y }: Point,\n  itemsRect: DOMRect[],\n  { fallbackToClosest = false } = {}\n): number => {\n  let smallestDistance = 10000\n  let smallestDistanceIndex = -1\n  for (let index = 0; index < itemsRect.length; index += 1) {\n    const rect = itemsRect[index]\n    // if it's inside the rect, we return the current index directly\n    if (x >= rect.left && x < rect.right && y >= rect.top && y < rect.bottom) {\n      return index\n    }\n    if (fallbackToClosest) {\n      // otherwise we compute the distance and update the smallest distance index if needed\n      const itemCenterX = (rect.left + rect.right) / 2\n      const itemCenterY = (rect.top + rect.bottom) / 2\n\n      const distance = Math.sqrt(Math.pow(x - itemCenterX, 2) + Math.pow(y - itemCenterY, 2)) // ** 2 operator is not supported on IE11\n      if (distance < smallestDistance) {\n        smallestDistance = distance\n        smallestDistanceIndex = index\n      }\n    }\n  }\n  return smallestDistanceIndex\n}\n","import React from 'react'\n\nimport { Point } from './types'\n\nconst getMousePoint = (e: MouseEvent | React.MouseEvent): Point => ({\n  x: Number(e.clientX),\n  y: Number(e.clientY),\n})\n\nconst getTouchPoint = (touch: Touch | React.Touch): Point => ({\n  x: Number(touch.clientX),\n  y: Number(touch.clientY),\n})\n\nconst getPointInContainer = (point: Point, containerTopLeft: Point): Point => {\n  return {\n    x: point.x - containerTopLeft.x,\n    y: point.y - containerTopLeft.y,\n  }\n}\n\nconst preventDefault = (event: Event) => {\n  event.preventDefault()\n}\n\nconst disableContextMenu = () => {\n  window.addEventListener('contextmenu', preventDefault, { capture: true, passive: false })\n}\n\nconst enableContextMenu = () => {\n  window.removeEventListener('contextmenu', preventDefault)\n}\n\nexport type OnStartArgs = { point: Point; pointInWindow: Point }\nexport type OnMoveArgs = { point: Point; pointInWindow: Point }\n\ntype UseDragProps = {\n  onStart?: (args: OnStartArgs) => void\n  onMove?: (args: OnMoveArgs) => void\n  onEnd?: () => void\n  allowDrag?: boolean\n  containerRef: React.MutableRefObject<HTMLElement | null>\n  knobs?: HTMLElement[]\n}\n\nexport const useDrag = ({\n  onStart,\n  onMove,\n  onEnd,\n  allowDrag = true,\n  containerRef,\n  knobs,\n}: UseDragProps) => {\n  // contains the top-left coordinates of the container in the window. Set on drag start and used in drag move\n  const containerPositionRef = React.useRef<Point>({ x: 0, y: 0 })\n  // on touch devices, we only start the drag gesture after pressing the item 200ms.\n  // this ref contains the timer id to be able to cancel it\n  const handleTouchStartTimerRef = React.useRef<number | undefined>(undefined)\n  // on non-touch device, we don't call onStart on mouse down but on the first mouse move\n  // we do this to let the user clicks on clickable element inside the container\n  // this means that the drag gesture actually starts on the fist move\n  const isFirstMoveRef = React.useRef(false)\n  // see https://twitter.com/ValentinHervieu/status/1324407814970920968\n  // we do this so that the parent doesn't have to use `useCallback()` for these callbacks\n  const callbacksRef = React.useRef({ onStart, onMove, onEnd })\n\n  // instead of relying on hacks to know if the device is a touch device or not,\n  // we track this using an onTouchStart listener on the document. (see https://codeburst.io/the-only-way-to-detect-touch-with-javascript-7791a3346685)\n  const [isTouchDevice, setTouchDevice] = React.useState(false)\n\n  React.useEffect(() => {\n    callbacksRef.current = { onStart, onMove, onEnd }\n  }, [onStart, onMove, onEnd])\n\n  const cancelTouchStart = () => {\n    if (handleTouchStartTimerRef.current) {\n      window.clearTimeout(handleTouchStartTimerRef.current)\n    }\n  }\n\n  const saveContainerPosition = React.useCallback(() => {\n    if (containerRef.current) {\n      const bounds = containerRef.current.getBoundingClientRect()\n      containerPositionRef.current = { x: bounds.left, y: bounds.top }\n    }\n  }, [containerRef])\n\n  const onDrag = React.useCallback((pointInWindow: Point) => {\n    const point = getPointInContainer(pointInWindow, containerPositionRef.current)\n    if (callbacksRef.current.onMove) {\n      callbacksRef.current.onMove({ pointInWindow, point })\n    }\n  }, [])\n\n  const onMouseMove = React.useCallback(\n    (e: MouseEvent) => {\n      // if this is the first move, we trigger the onStart logic\n      if (isFirstMoveRef.current) {\n        isFirstMoveRef.current = false\n        const pointInWindow = getMousePoint(e)\n        const point = getPointInContainer(pointInWindow, containerPositionRef.current)\n        if (callbacksRef.current.onStart) {\n          callbacksRef.current.onStart({ point, pointInWindow })\n        }\n      }\n      // otherwise, we do the normal move logic\n      else {\n        onDrag(getMousePoint(e))\n      }\n    },\n    [onDrag]\n  )\n\n  const onTouchMove = React.useCallback(\n    (e: TouchEvent) => {\n      if (e.cancelable) {\n        // Prevent the whole page from scrolling\n        e.preventDefault()\n        onDrag(getTouchPoint(e.touches[0]))\n      } else {\n        // if the event is not cancelable, it means the browser is currently scrolling\n        // which cannot be interrupted. Thus we cancel the drag gesture.\n        document.removeEventListener('touchmove', onTouchMove)\n        if (callbacksRef.current.onEnd) {\n          callbacksRef.current.onEnd()\n        }\n      }\n    },\n    [onDrag]\n  )\n\n  const onMouseUp = React.useCallback(() => {\n    isFirstMoveRef.current = false\n    document.removeEventListener('mousemove', onMouseMove)\n    document.removeEventListener('mouseup', onMouseUp)\n    if (callbacksRef.current.onEnd) {\n      callbacksRef.current.onEnd()\n    }\n  }, [onMouseMove])\n\n  const onTouchEnd = React.useCallback(() => {\n    document.removeEventListener('touchmove', onTouchMove)\n    document.removeEventListener('touchend', onTouchEnd)\n    enableContextMenu()\n    if (callbacksRef.current.onEnd) {\n      callbacksRef.current.onEnd()\n    }\n  }, [onTouchMove])\n\n  const onMouseDown = React.useCallback(\n    (e: React.MouseEvent<HTMLElement, MouseEvent>) => {\n      if (e.button !== 0) {\n        // we don't want to handle clicks other than left ones\n        return\n      }\n\n      if (knobs?.length && !knobs.find((knob) => knob.contains(e.target as Node))) {\n        return\n      }\n\n      document.addEventListener('mousemove', onMouseMove)\n      document.addEventListener('mouseup', onMouseUp)\n\n      saveContainerPosition()\n\n      // mark the next move as being the first one\n      isFirstMoveRef.current = true\n    },\n    [onMouseMove, onMouseUp, saveContainerPosition, knobs]\n  )\n\n  const handleTouchStart = React.useCallback(\n    (point: Point, pointInWindow: Point) => {\n      document.addEventListener('touchmove', onTouchMove, { capture: false, passive: false })\n      document.addEventListener('touchend', onTouchEnd)\n      disableContextMenu()\n\n      if (callbacksRef.current.onStart) {\n        callbacksRef.current.onStart({ point, pointInWindow })\n      }\n    },\n    [onTouchEnd, onTouchMove]\n  )\n\n  const onTouchStart = React.useCallback(\n    (e: TouchEvent) => {\n      if (knobs?.length && !knobs.find((knob) => knob.contains(e.target as Node))) {\n        return\n      }\n\n      saveContainerPosition()\n\n      const pointInWindow = getTouchPoint(e.touches[0])\n      const point = getPointInContainer(pointInWindow, containerPositionRef.current)\n\n      // we wait 120ms to start the gesture to be sure that the user\n      // is not trying to scroll the page\n      handleTouchStartTimerRef.current = window.setTimeout(\n        () => handleTouchStart(point, pointInWindow),\n        120\n      )\n    },\n    [handleTouchStart, saveContainerPosition, knobs]\n  )\n\n  const detectTouchDevice = React.useCallback(() => {\n    setTouchDevice(true)\n    document.removeEventListener('touchstart', detectTouchDevice)\n  }, [])\n\n  // if the user is scrolling on mobile, we cancel the drag gesture\n  const touchScrollListener = React.useCallback(() => {\n    cancelTouchStart()\n  }, [])\n\n  React.useLayoutEffect(() => {\n    if (isTouchDevice) {\n      const container = containerRef.current\n\n      if (allowDrag) {\n        container?.addEventListener('touchstart', onTouchStart, { capture: true, passive: false })\n        // we are adding this touchmove listener to cancel drag if user is scrolling\n        // however, it's also important to have a touchmove listener always set\n        // with non-capture and non-passive option to prevent an issue on Safari\n        // with e.preventDefault (https://github.com/atlassian/react-beautiful-dnd/issues/1374)\n        document.addEventListener('touchmove', touchScrollListener, {\n          capture: false,\n          passive: false,\n        })\n        document.addEventListener('touchend', touchScrollListener, {\n          capture: false,\n          passive: false,\n        })\n      }\n\n      return () => {\n        container?.removeEventListener('touchstart', onTouchStart, { capture: true })\n        document.removeEventListener('touchmove', touchScrollListener, { capture: false })\n        document.removeEventListener('touchend', touchScrollListener, { capture: false })\n        document.removeEventListener('touchmove', onTouchMove)\n        document.removeEventListener('touchend', onTouchEnd)\n        enableContextMenu()\n        cancelTouchStart()\n      }\n    }\n    // if non-touch device\n    document.addEventListener('touchstart', detectTouchDevice)\n    return () => {\n      document.removeEventListener('touchstart', detectTouchDevice)\n      document.removeEventListener('mousemove', onMouseMove)\n      document.removeEventListener('mouseup', onMouseUp)\n    }\n  }, [\n    isTouchDevice,\n    allowDrag,\n    detectTouchDevice,\n    onMouseMove,\n    onTouchMove,\n    touchScrollListener,\n    onTouchEnd,\n    onMouseUp,\n    containerRef,\n    onTouchStart,\n  ])\n\n  // on touch devices, we cannot attach the onTouchStart directly via React:\n  // Touch handlers must be added with {passive: false} to be cancelable.\n  // https://developers.google.com/web/updates/2017/01/scrolling-intervention\n  return isTouchDevice ? {} : { onMouseDown }\n}\n\ntype UseDropTargetProps = Partial<{\n  show: (sourceRect: DOMRect) => void\n  hide: () => void\n  setPosition: (index: number, itemsRect: DOMRect[], lockAxis?: 'x' | 'y') => void\n  render: () => React.ReactElement\n}>\n\nexport const useDropTarget = (content?: React.ReactNode): UseDropTargetProps => {\n  const dropTargetRef = React.useRef<HTMLDivElement | null>(null)\n\n  if (!content) {\n    return {}\n  }\n\n  const show = (sourceRect: DOMRect) => {\n    if (dropTargetRef.current) {\n      dropTargetRef.current.style.width = `${sourceRect.width}px`\n      dropTargetRef.current.style.height = `${sourceRect.height}px`\n      dropTargetRef.current.style.opacity = '1'\n      dropTargetRef.current.style.visibility = 'visible'\n    }\n  }\n\n  const hide = () => {\n    if (dropTargetRef.current) {\n      dropTargetRef.current.style.opacity = '0'\n      dropTargetRef.current.style.visibility = 'hidden'\n    }\n  }\n\n  const setPosition = (index: number, itemsRect: DOMRect[], lockAxis?: 'x' | 'y') => {\n    if (dropTargetRef.current) {\n      const sourceRect = itemsRect[index]\n      const newX = lockAxis === 'y' ? sourceRect.left : itemsRect[index].left\n      const newY = lockAxis === 'x' ? sourceRect.top : itemsRect[index].top\n\n      dropTargetRef.current.style.transform = `translate3d(${newX}px, ${newY}px, 0px)`\n    }\n  }\n\n  const DropTargetWrapper = (): React.ReactElement => (\n    <div\n      ref={dropTargetRef}\n      aria-hidden\n      style={{\n        opacity: 0,\n        visibility: 'hidden',\n        position: 'fixed',\n        top: 0,\n        left: 0,\n        pointerEvents: 'none',\n      }}\n    >\n      {content}\n    </div>\n  )\n\n  return {\n    show,\n    hide,\n    setPosition,\n    render: DropTargetWrapper,\n  }\n}\n","import arrayMove from 'array-move'\nimport React, { HTMLAttributes } from 'react'\n\nimport { findItemIndexAtPosition } from './helpers'\nimport { useDrag, useDropTarget } from './hooks'\nimport { Point } from './types'\n\nconst DEFAULT_CONTAINER_TAG = 'div'\n\ntype Props<TTag extends keyof JSX.IntrinsicElements> = HTMLAttributes<TTag> & {\n  children: React.ReactNode\n  /** Determines whether drag functionality is enabled, defaults to true */\n  allowDrag?: boolean\n  /** Called when the user finishes a sorting gesture. */\n  onSortEnd: (oldIndex: number, newIndex: number) => void\n  /** Class applied to the item being dragged */\n  draggedItemClassName?: string\n  /** Determines which type of html tag will be used for a container element */\n  as?: TTag\n  /** Determines if an axis should be locked */\n  lockAxis?: 'x' | 'y'\n  /** Reference to the Custom Holder element */\n  customHolderRef?: React.RefObject<HTMLElement | null>\n  /** Drop target to be used when dragging */\n  dropTarget?: React.ReactNode\n}\n\n// this context is only used so that SortableItems can register/remove themselves\n// from the items list\ntype Context = {\n  registerItem: (item: HTMLElement) => void\n  removeItem: (item: HTMLElement) => void\n  registerKnob: (item: HTMLElement) => void\n  removeKnob: (item: HTMLElement) => void\n}\n\nconst SortableListContext = React.createContext<Context | undefined>(undefined)\nconst SortableList = <TTag extends keyof JSX.IntrinsicElements = typeof DEFAULT_CONTAINER_TAG>({\n  children,\n  allowDrag = true,\n  onSortEnd,\n  draggedItemClassName,\n  as,\n  lockAxis,\n  customHolderRef,\n  dropTarget,\n  ...rest\n}: Props<TTag>) => {\n  // this array contains the elements than can be sorted (wrapped inside SortableItem)\n  const itemsRef = React.useRef<HTMLElement[]>([])\n  // this array contains the coordinates of each sortable element (only computed on dragStart and used in dragMove for perf reason)\n  const itemsRect = React.useRef<DOMRect[]>([])\n  // Hold all registered knobs\n  const knobs = React.useRef<HTMLElement[]>([])\n  // contains the container element\n  const containerRef = React.useRef<HTMLElement | null>(null)\n  // contains the target element (copy of the source element)\n  const targetRef = React.useRef<HTMLElement | null>(null)\n  // contains the index in the itemsRef array of the element being dragged\n  const sourceIndexRef = React.useRef<number | undefined>(undefined)\n  // contains the index in the itemsRef of the element to be exchanged with the source item\n  const lastTargetIndexRef = React.useRef<number | undefined>(undefined)\n  // contains the offset point where the initial drag occurred to be used when dragging the item\n  const offsetPointRef = React.useRef<Point>({ x: 0, y: 0 })\n  // contains the dropTarget logic\n  const dropTargetLogic = useDropTarget(dropTarget)\n\n  React.useEffect(() => {\n    const holder = customHolderRef?.current || document.body\n    return () => {\n      // cleanup the target element from the DOM when SortableList in unmounted\n      if (targetRef.current) {\n        holder.removeChild(targetRef.current)\n      }\n    }\n  }, [customHolderRef])\n\n  const updateTargetPosition = (position: Point) => {\n    if (targetRef.current && sourceIndexRef.current !== undefined) {\n      const offset = offsetPointRef.current\n      const sourceRect = itemsRect.current[sourceIndexRef.current]\n      const newX = lockAxis === 'y' ? sourceRect.left : position.x - offset.x\n      const newY = lockAxis === 'x' ? sourceRect.top : position.y - offset.y\n\n      // we use `translate3d` to force using the GPU if available\n      targetRef.current.style.transform = `translate3d(${newX}px, ${newY}px, 0px)`\n    }\n  }\n\n  const copyItem = React.useCallback(\n    (sourceIndex: number) => {\n      if (!containerRef.current) {\n        return\n      }\n\n      const source = itemsRef.current[sourceIndex]\n      const sourceRect = itemsRect.current[sourceIndex]\n\n      const copy = source.cloneNode(true) as HTMLElement\n\n      // added the \"dragged\" class name\n      if (draggedItemClassName) {\n        draggedItemClassName.split(' ').forEach((c) => copy.classList.add(c))\n      }\n\n      // we ensure the copy has the same size than the source element\n      copy.style.width = `${sourceRect.width}px`\n      copy.style.height = `${sourceRect.height}px`\n      // we place the target starting position to the top left of the window\n      // it will then be moved relatively using `transform: translate3d()`\n      copy.style.position = 'fixed'\n      copy.style.margin = '0'\n      copy.style.top = '0'\n      copy.style.left = '0'\n\n      const sourceCanvases = source.querySelectorAll('canvas')\n      copy.querySelectorAll('canvas').forEach((canvas, index) => {\n        canvas.getContext('2d')?.drawImage(sourceCanvases[index], 0, 0)\n      })\n\n      const holder = customHolderRef?.current || document.body\n      holder.appendChild(copy)\n\n      targetRef.current = copy\n    },\n    [customHolderRef, draggedItemClassName]\n  )\n\n  const listeners = useDrag({\n    allowDrag,\n    containerRef,\n    knobs: knobs.current,\n    onStart: ({ pointInWindow }) => {\n      if (!containerRef.current) {\n        return\n      }\n\n      itemsRect.current = itemsRef.current.map((item) => item.getBoundingClientRect())\n\n      const sourceIndex = findItemIndexAtPosition(pointInWindow, itemsRect.current)\n      // if we are not starting the drag gesture on a SortableItem, we exit early\n      if (sourceIndex === -1) {\n        return\n      }\n\n      // saving the index of the item being dragged\n      sourceIndexRef.current = sourceIndex\n\n      // the item being dragged is copied to the document body and will be used as the target\n      copyItem(sourceIndex)\n\n      // hide source during the drag gesture\n      const source = itemsRef.current[sourceIndex]\n      source.style.opacity = '0'\n      source.style.visibility = 'hidden'\n\n      // get the offset between the source item's window position relative to the point in window\n      const sourceRect = source.getBoundingClientRect()\n      offsetPointRef.current = {\n        x: pointInWindow.x - sourceRect.left,\n        y: pointInWindow.y - sourceRect.top,\n      }\n\n      updateTargetPosition(pointInWindow)\n      dropTargetLogic.show?.(sourceRect)\n\n      // Adds a nice little physical feedback\n      if (window.navigator.vibrate) {\n        window.navigator.vibrate(100)\n      }\n    },\n    onMove: ({ pointInWindow }) => {\n      updateTargetPosition(pointInWindow)\n\n      const sourceIndex = sourceIndexRef.current\n      // if there is no source, we exit early (happened when drag gesture was started outside a SortableItem)\n      if (sourceIndex === undefined || sourceIndexRef.current === undefined) {\n        return\n      }\n\n      const sourceRect = itemsRect.current[sourceIndexRef.current]\n      const targetPoint: Point = {\n        x: lockAxis === 'y' ? sourceRect.left : pointInWindow.x,\n        y: lockAxis === 'x' ? sourceRect.top : pointInWindow.y,\n      }\n\n      const targetIndex = findItemIndexAtPosition(targetPoint, itemsRect.current, {\n        fallbackToClosest: true,\n      })\n      // if not target detected, we don't need to update other items' position\n      if (targetIndex === -1) {\n        return\n      }\n      // we keep track of the last target index (to be passed to the onSortEnd callback)\n      lastTargetIndexRef.current = targetIndex\n\n      const isMovingRight = sourceIndex < targetIndex\n\n      // in this loop, we go over each sortable item and see if we need to update their position\n      for (let index = 0; index < itemsRef.current.length; index += 1) {\n        const currentItem = itemsRef.current[index]\n        const currentItemRect = itemsRect.current[index]\n        // if current index is between sourceIndex and targetIndex, we need to translate them\n        if (\n          (isMovingRight && index >= sourceIndex && index <= targetIndex) ||\n          (!isMovingRight && index >= targetIndex && index <= sourceIndex)\n        ) {\n          // we need to move the item to the previous or next item position\n          const nextItemRects = itemsRect.current[isMovingRight ? index - 1 : index + 1]\n          if (nextItemRects) {\n            const translateX = nextItemRects.left - currentItemRect.left\n            const translateY = nextItemRects.top - currentItemRect.top\n            // we use `translate3d` to force using the GPU if available\n            currentItem.style.transform = `translate3d(${translateX}px, ${translateY}px, 0px)`\n          }\n        }\n        // otherwise, the item should be at its original position\n        else {\n          currentItem.style.transform = 'translate3d(0,0,0)'\n        }\n        // we want the translation to be animated\n        currentItem.style.transitionDuration = '300ms'\n      }\n\n      dropTargetLogic.setPosition?.(lastTargetIndexRef.current, itemsRect.current, lockAxis)\n    },\n    onEnd: () => {\n      // we reset all items translations (the parent is expected to sort the items in the onSortEnd callback)\n      for (let index = 0; index < itemsRef.current.length; index += 1) {\n        const currentItem = itemsRef.current[index]\n        currentItem.style.transform = ''\n        currentItem.style.transitionDuration = ''\n      }\n\n      const sourceIndex = sourceIndexRef.current\n      if (sourceIndex !== undefined) {\n        // show the source item again\n        const source = itemsRef.current[sourceIndex]\n        if (source) {\n          source.style.opacity = '1'\n          source.style.visibility = ''\n        }\n\n        const targetIndex = lastTargetIndexRef.current\n        if (targetIndex !== undefined) {\n          if (sourceIndex !== targetIndex) {\n            // sort our internal items array\n            itemsRef.current = arrayMove(itemsRef.current, sourceIndex, targetIndex)\n            // let the parent know\n            onSortEnd(sourceIndex, targetIndex)\n          }\n        }\n      }\n      sourceIndexRef.current = undefined\n      lastTargetIndexRef.current = undefined\n      dropTargetLogic.hide?.()\n\n      // cleanup the target element from the DOM\n      if (targetRef.current) {\n        const holder = customHolderRef?.current || document.body\n        holder.removeChild(targetRef.current)\n        targetRef.current = null\n      }\n    },\n  })\n\n  const registerItem = React.useCallback((item: HTMLElement) => {\n    itemsRef.current.push(item)\n  }, [])\n\n  const removeItem = React.useCallback((item: HTMLElement) => {\n    const index = itemsRef.current.indexOf(item)\n    if (index !== -1) {\n      itemsRef.current.splice(index, 1)\n    }\n  }, [])\n\n  const registerKnob = React.useCallback((item: HTMLElement) => {\n    knobs.current.push(item)\n  }, [])\n\n  const removeKnob = React.useCallback((item: HTMLElement) => {\n    const index = knobs.current.indexOf(item)\n\n    if (index !== -1) {\n      knobs.current.splice(index, 1)\n    }\n  }, [])\n\n  // we need to memoize the context to avoid re-rendering every children of the context provider\n  // when not needed\n  const context = React.useMemo(() => ({ registerItem, removeItem, registerKnob, removeKnob }), [\n    registerItem,\n    removeItem,\n    registerKnob,\n    removeKnob,\n  ])\n\n  return React.createElement(\n    as || DEFAULT_CONTAINER_TAG,\n    {\n      ...(allowDrag ? listeners : {}),\n      ...rest,\n      ref: containerRef,\n    },\n    <SortableListContext.Provider value={context}>\n      {children}\n      {dropTargetLogic.render?.()}\n    </SortableListContext.Provider>\n  )\n}\n\nexport default SortableList\n\ntype ItemProps = {\n  children: React.ReactElement\n}\n\n/**\n * SortableItem only adds a ref to its children so that we can register it to the main Sortable\n */\nexport const SortableItem = ({ children }: ItemProps) => {\n  const context = React.useContext(SortableListContext)\n  if (!context) {\n    throw new Error('SortableItem must be a child of SortableList')\n  }\n  const { registerItem, removeItem } = context\n  const elementRef = React.useRef<HTMLElement | null>(null)\n\n  React.useEffect(() => {\n    const currentItem = elementRef.current\n    if (currentItem) {\n      registerItem(currentItem)\n    }\n\n    return () => {\n      if (currentItem) {\n        removeItem(currentItem)\n      }\n    }\n    // if the children changes, we want to re-register the DOM node\n  }, [registerItem, removeItem, children])\n\n  return React.cloneElement(children, { ref: elementRef })\n}\n\nexport const SortableKnob = ({ children }: ItemProps) => {\n  const context = React.useContext(SortableListContext)\n\n  if (!context) {\n    throw new Error('SortableKnob must be a child of SortableList')\n  }\n\n  const { registerKnob, removeKnob } = context\n\n  const elementRef = React.useRef<HTMLElement | null>(null)\n\n  React.useEffect(() => {\n    const currentItem = elementRef.current\n\n    if (currentItem) {\n      registerKnob(currentItem)\n    }\n\n    return () => {\n      if (currentItem) {\n        removeKnob(currentItem)\n      }\n    }\n    // if the children changes, we want to re-register the DOM node\n  }, [registerKnob, removeKnob, children])\n\n  return React.cloneElement(children, { ref: elementRef })\n}\n"],"names":["findItemIndexAtPosition","_a","itemsRect","_b","x","y","_c","fallbackToClosest","smallestDistance","smallestDistanceIndex","index","length","rect","left","right","top","bottom","itemCenterX","itemCenterY","distance","Math","sqrt","pow","getMousePoint","e","Number","clientX","clientY","getTouchPoint","touch","getPointInContainer","point","containerTopLeft","preventDefault","event","enableContextMenu","window","removeEventListener","useDrag","onStart","onMove","onEnd","allowDrag","containerRef","knobs","containerPositionRef","React","useRef","handleTouchStartTimerRef","undefined","isFirstMoveRef","callbacksRef","useState","isTouchDevice","setTouchDevice","useEffect","current","cancelTouchStart","clearTimeout","saveContainerPosition","useCallback","bounds","getBoundingClientRect","onDrag","pointInWindow","onMouseMove","onTouchMove","cancelable","touches","document","onMouseUp","onTouchEnd","onMouseDown","button","find","knob","contains","target","addEventListener","handleTouchStart","capture","passive","onTouchStart","setTimeout","detectTouchDevice","touchScrollListener","useLayoutEffect","container_1","SortableListContext","createContext","children","context","useContext","Error","registerItem","removeItem","elementRef","currentItem","cloneElement","ref","registerKnob","removeKnob","onSortEnd","draggedItemClassName","as","lockAxis","customHolderRef","dropTarget","rest","itemsRef","targetRef","sourceIndexRef","lastTargetIndexRef","offsetPointRef","dropTargetLogic","content","dropTargetRef","show","sourceRect","style","width","height","opacity","visibility","hide","setPosition","newX","newY","transform","render","position","pointerEvents","useDropTarget","holder","body","removeChild","updateTargetPosition","offset","copyItem","sourceIndex","source","copy","cloneNode","split","forEach","c","classList","add","margin","sourceCanvases","querySelectorAll","canvas","getContext","drawImage","appendChild","listeners","map","item","navigator","vibrate","targetPoint","targetIndex","isMovingRight","currentItemRect","nextItemRects","translateX","translateY","transitionDuration","arrayMove","push","indexOf","splice","useMemo","createElement","Provider","value"],"mappings":"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"}